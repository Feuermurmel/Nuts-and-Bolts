package ch.feuermurmel.nutsandbolts.body

import java.lang.Math.{cos, max, round, sin, sqrt}

import ch.feuermurmel.nutsandbolts.polyhedron.Point
import ch.feuermurmel.nutsandbolts.util.MathUtil.{closedRange, goldenAngle, quantile, tau}

case class CylindricalBody(surface: Surface, start: Double, end: Double) extends Body {
  private def guessPartRadius(zRange: Seq[Double]) = {
    val ends = zRange
      .zipWithIndex
      .flatMap({ case (z, i) =>
        surface(z, i * goldenAngle).hull.map(_.end)
      })

    if (ends.isEmpty)
      None
    else
      Some(quantile(ends, 0.95))
  }

  def toPolyhedron(resolution: Double) = {
    val zRange = closedRange(start, end, resolution)

    val cSteps = guessPartRadius(zRange) match {
      case Some(partRadius) =>
        // Use a resolution for cResolution * partRadius that is smaller by a factor of sqrt(3) / 2 than resolution so that the triangles of the generated mesh are equilateral at a radius of partRadius.
        max(4, round(partRadius * tau / resolution * sqrt(3) / 2).toInt)
      case None =>
        // The Part doesn't seem to intersect rays almost anywhere. Just use a very low number of steps for cResolution.
        4
    }

    val cResolution = tau / cSteps
    val cRange = (0 until cSteps).map(cResolution * _)

    // i travels along c, j travels along z
    def combineIndex(i: Int, j: Int) =
      Parameter(zRange(j), cRange(i) - cResolution * j / 2)

    def pointOnRay(parameter: Parameter, value: Double) =
      if (value > 0)
        Point(cos(parameter.c) * value, sin(parameter.c) * value, parameter.z)
      else
      // For negative values, we just generate a point at the Z-axis. This should be more efficient than clamping all rays generated by the surface.
        Point(0, 0, parameter.z)

    Body.constructPolyhedron[Parameter](cRange.size, zRange.size, combineIndex, surface(_), pointOnRay, wrapI = true)
  }
}

object CylindricalBody {
  /**
    * Half-plane with a border with the specified distance from the origin.
    */
  private def halfPlane(c0: Double, distance: Double)(c: Double) = {
    val unitValue = cos(c - c0)

    if (distance > 0)
      if (unitValue > 0)
        Ray(0, distance / unitValue)
      else
        Ray(0, Double.PositiveInfinity)
    else
      if (unitValue > 0)
        Ray.empty
      else
        Ray(distance / unitValue, Double.PositiveInfinity)
  }

  private def disc(c0: Double, distance: Double, r: Double)(c: Double) = {
    val v = distance * cos(c - c0)
    val q = sqrt(v * v + r * r - distance * distance)

    val start = v - q
    val end = v + q

    if (start < end)
      Ray(start, end)
    else
      Ray.empty
  }

  def halfSpace(c0: Double, distance: Double) =
    Surface(p => halfPlane(c0, distance)(p.c))

  def horizontalCylinder(z0: Double, c0: Double, distance: Double, r: Double) =
    Surface({ p =>
      val z = p.z - z0
      val sliceRadius = sqrt(r * r - z * z)

      val outerDistance = distance + sliceRadius
      val innerDistance = distance - sliceRadius

      if (innerDistance < outerDistance)
        halfPlane(c0, outerDistance)(p.c) / halfPlane(c0, innerDistance)(p.c)
      else
        Ray.empty
    })

  def verticalCylinder(c0: Double, distance: Double, r: Double) =
    Surface(p => disc(c0, distance, r)(p.c))

  def horizontalTorus(z0: Double, c0: Double, distance: Double, r1: Double, r2: Double) =
    Surface({ p =>
      val z = p.z - z0
      val radiusOffset = sqrt(r2 * r2 - z * z)

      val outerRadius = r1 + radiusOffset
      val innerRadius = r1 - radiusOffset

      if (innerRadius < outerRadius)
        disc(c0, distance, outerRadius)(p.c) / disc(c0, distance, innerRadius)(p.c)
      else
        Ray.empty
    })

  def blubb =
    Surface(p => halfPlane(0, p.z)(p.c))
}
