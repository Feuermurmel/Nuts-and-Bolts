package ch.feuermurmel.nutsandbolts.body

import java.lang.Math.{cos, max, round, sin, sqrt}

import ch.feuermurmel.nutsandbolts.polyhedron.Point
import ch.feuermurmel.nutsandbolts.util.MathUtil.{closedRange, goldenAngle, quantile, tau}

case class CylindricalBody(surface: Surface, start: Double, end: Double) extends Body {
  private def guessPartRadius(zRange: Seq[Double]) = {
    val ends = zRange
      .zipWithIndex
      .flatMap({ case (z, i) =>
        surface(z, i * goldenAngle).hull.map(_.end)
      })

    if (ends.isEmpty)
      None
    else
      Some(quantile(ends, 0.95))
  }

  def toPolyhedron(resolution: Double) = {
    val zRange = closedRange(start, end, resolution)

    val cSteps = guessPartRadius(zRange) match {
      case Some(partRadius) =>
        // Use a resolution for cResolution * partRadius that is smaller by a factor of sqrt(3) / 2 than resolution so that the triangles of the generated mesh are equilateral at a radius of partRadius.
        max(4, round(partRadius * tau / resolution * sqrt(3) / 2).toInt)
      case None =>
        // The Part doesn't seem to intersect rays almost anywhere. Just use a very low number of steps for cResolution.
        4
    }

    val cResolution = tau / cSteps
    val cRange = (0 until cSteps).map(cResolution * _)

    // i travels along c, j travels along z
    def combineIndex(i: Int, j: Int) =
      Parameter(zRange(j), cRange(i) - cResolution * j / 2)

    def pointOnRay(parameter: Parameter, value: Double) =
      if (value > 0)
        Point(cos(parameter.c) * value, sin(parameter.c) * value, parameter.z)
      else
      // For negative values, we just generate a point at the Z-axis. This should be more efficient than clamping all rays generated by the surface.
        Point(0, 0, parameter.z)

    Body.constructPolyhedron[Parameter](cRange.size, zRange.size, combineIndex, surface(_), pointOnRay, wrapI = true)
  }
}
